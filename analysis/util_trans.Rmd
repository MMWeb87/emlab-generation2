---
title: "Example Report"
output:
  html_document:
    df_print: paged
  html_notebook: default
  pdf_document: default
editor_options: 
  chunk_output_type: console
---

This report show that the results can exported in an [R Markdown](http://rmarkdown.rstudio.com) Notebook.


```{r setup, include=FALSE}

knitr::opts_chunk$set(
  echo = FALSE, 
  message = FALSE, 
  warning = FALSE,
  fig.width= 10,
  fig.asp=0.5
  #out.width= 10
  )

source(file = "emlab/init.R")

# theme for ggplot
theme_set(
  theme_bw(base_size = 13) + 
    theme(
      legend.title=element_blank(),
      legend.spacing.x = unit(0.1, 'cm')
    )
)


# global vars
filters <- list(
  iterations = c(iteration_min,iteration_max),
  unit_prefix = "M")
# needed for report
assign("global_unit",filters$unit, envir = .GlobalEnv)
```


# Descriptive statistics

I use this to figure out average, modelled return levels.

```{r}

return_analysis_data <- raw_financialexpectations_results %>% 
  select(iteration, tick, market, producer, technology, investmentRound, ROE = ROE.modelled, ROI) #%>% 
  #filter(iteration == 1)
  
# I want to see per tick what the maximum ROE is

return_analysis_per_tick <- return_analysis_data %>%   
  group_by(market, technology, tick) %>% 
  summarise(
    max_ROE = max(ROE),
    min_ROE = min(ROE),
    ROE_average = mean(ROE),
    ROE_sd = sd(ROE))
  

return_analysis_data_2 <- return_analysis_data %>%
  left_join(return_analysis_per_tick, by = c("market", "technology", "tick")) %>% 
  mutate(relative_ROE = ROE / max_ROE) 

# return_analysis_data_2%>% 
#   arrange(market,technology,tick)


return_analysis_data_2%>% 
  group_by(market, technology, investmentRound) %>% 
  summarise(
    ROE_average = mean(ROE),
    ROE_sd = sd(ROE),
    ROE_average_rel = mean(relative_ROE),
    ROE_sd_rel = sd(relative_ROE)
  ) %>% 
  ggplot(mapping = aes(x = investmentRound, y = ROE_average_rel, color = technology)) +
  #geom_line() +
  geom_smooth(se = F) +
  facet_grid( ~ market, scales = "free")


# ROE relative are relative to the highest ROE (of a technology and market, estimated by all producers) per tick. 
## needs to be percent of max



return_analysis_data %>% 
  group_by(market, technology, tick) %>% 
  filter(technology %in% c("Photovoltaic PGT", "Onshore wind PGT", "Offshore wind PGT")) %>% 
  summarise(
    ROE_average = mean(ROE),
    ROE_sd = sd(ROE)
  ) %>% 
  ggplot(mapping = aes(x = tick, y = ROE_average, color = technology)) +
  geom_line() +
  scale_y_log10(labels = scales::percent) +
  #geom_smooth(se = F) +
  facet_grid( ~ market, scales = "free")






return_analysis_data %>% 
  filter(technology %in% c("Photovoltaic PGT", "Onshore wind PGT", "Offshore wind PGT")) %>% 
  ggplot(mapping = aes(x = tick, y = ROE, color = technology)) +
  #geom_boxplot() +
  geom_line() +
  scale_y_continuous(labels = scales::percent) +
  facet_grid( ~ market, scales = "free")

# Mues jetzt das chöne bruuch zum anders analysiere!
# goal is to have an average ROI per tick. (Rounds will be differ, but tiks probably be comparable)

# taking as average the median as there, most expectations took place. 
# for the scalling, take quartiles, as between them, most cases are. 

```


## Analysis of problem and treatment

These figures show that the expected ROEs in the investment roles are often very high (compared to reality probably too high and hence it is necessary to treat the data).

```{r}
return_analysis_data %>%
  ungroup() %>% 
  ggplot(mapping = aes(x = tick, y = ROE, color = technology)) +
  geom_boxplot() +
  scale_y_log10(labels = scales::percent) +
  facet_grid( ~ market, scales = "free")

return_analysis_data %>%
  ungroup() %>% 
  group_by(technology) %>% 
  summarise(mean = mean(ROE))


return_analysis_data %>%
  ungroup() %>% 
  group_by(technology) %>% 
  summarise(
    mean = mean(ROE))

```



To treat: 

IMPORTANT: need several iterations for a reasonable result

1. Let this run with a scenario with "linear" mapping

2. Import into eclipse

```{r functions}


```

```{r calculate boundaries of function}

quibble <- function(x, q = c(0.25, 0.5, 0.75)) {
  tibble(x = quantile(x, q), q = q)
}


#' This returns from a df with market and technology fields, the lowst porint near the 25%, the highest near the 75% percentile, as well as the mean of a variable (e.g. ROE). Not so efficient thoug.
#' 
#'
#' @param df 
#' @param var 
#' @param market 
#' @param technology 
#'
#' @return
#' @export
#'
#' @examples
quantile_summary <- function(df, var, market, technology){
  
  var <- enquo(var)
  
  df_specific <- df %>%
    filter(
      technology == !!technology,
      market == !!market) %>% 
    ungroup()

  
  quantile_tibble <- df_specific %>%  
    group_by(iteration) %>% 
    nest() %>% 
    mutate(quantiles = map(data, function(data){
     
      data %>% 
        summarise(
          quibble(ROE, c(0.25, 0.75))) %>% 
        spread(key = q, value = x)
      
    } ))

  
  average_roes_in_50_quantiles <- quantile_tibble %>% 
    mutate(
      summary = map2(quantiles, data, function(quantiles, data) {

      data %>%
        filter(
          between(!!var, quantiles$`0.25`, quantiles$`0.75`)) %>% 
        summarise(
          modelled_roe_mean = mean(ROE),
          modelled_roe_max = max(ROE),
          modelled_roe_min = min(ROE)
        )
      })) %>% 
    add_column(
      market = !!market,
      technology = !!technology
    ) %>% 
    unnest(cols = c(summary)) %>% 
    select(-data) %>% 
    ungroup()
  

  average_roes_in_50_quantiles
  
}

# These boundaries are the ROEs in which most ROEs data points lie (mean over several iterations)
# I treat others as outliers in the mapping function

tech_combinations <- crossing(
  market = c("DutchMarket","GermanMarket"),
  technology = c("Onshore wind PGT", "Offshore wind PGT", "Photovoltaic PGT")
)

boundaries <- map2_dfr(
  .x = tech_combinations$market, 
  .y = tech_combinations$technology, 
  .f = ~ quantile_summary(return_analysis_data, ROE, .x, .y))

final_boundaries <- boundaries %>% 
  group_by(market, technology) %>% 
  summarise(
    modelled_roe_mean = mean(modelled_roe_mean),
    modelled_roe_max = mean(modelled_roe_max),
    modelled_roe_min = mean(modelled_roe_min)
  )
 
```


Because things may change: idea: 1st run decide using linear algorithms and construct the mapping function, 2nd run decide using simple linear extrapolation of expected returns.  SO HARD TO BRING TO PAPER! AFTERWARS! MABE PLOT AND IMG HELPS!

In the next step, I construct the formula used to rescale returns from the model to returns one would observe in reality.

For onshore wind, most ROEs in 2017, in Germany were between 6% ±2% (EGLI). We expect that there are also outliers which are higher or lower.


```{r}


calculate_mapping_function <- function(roe_data){
  
  # actual returns (for which data is available or can be extrapolated)
  actual_utils <- seq(
    from = roe_data$real_roe_average - roe_data$real_roe_variation, 
    to = roe_data$real_roe_average + roe_data$real_roe_variation, 
    by = 0.01)
  
  # the range of utils from the model
  # to get the slope of the linear function, I divide the range between max and min of the 
  # actual returns by the number of actual_utils

  final_boundaries_function <- roe_data %>%
    select(mean = modelled_roe_mean, max = modelled_roe_max, min = modelled_roe_min) %>% 
    mutate(
      range = max - min,
      delta_y = 0.01,
      delta_x = range / (length(actual_utils) - 1),
      slope = delta_y / delta_x
      )
  
  # construct formula:
  # y = a + b*x; b => slope
  # a = y - b*x
  # I construc the intercept using the mean between max and mean, an the middle actual_utils
  
  
  final_boundaries_function_final <- final_boundaries_function %>% 
    mutate(
        intercept = median(actual_utils) - slope * mean 
    )
  
  
  tibble(
    intercept = final_boundaries_function_final$intercept,
    slope = final_boundaries_function$slope
  )
}

library(readxl)
actual_utils_df <- read_xlsx("../resources/sources/return_mapping/country_roes.xlsx")

final_function_parameters <- actual_utils_df %>% 
  left_join(final_boundaries, by = c("technology", "market")) %>% 
  group_by(technology, market) %>% 
  nest() %>% 
  mutate(
    mapping = map(data, calculate_mapping_function)
  ) %>% 
  unnest(cols = c(mapping, data))

final_function_parameters
write_csv(x = final_function_parameters, path =  "../resources/sources/return_mapping/final_functions.csv")

```

Quick and dirty construction of Java code

```{r}
 
write_lines(
  x = "", 
  path = "../resources/sources/return_mapping/mappingfunction_javacode.txt", 
  append = FALSE)

name_to_var <- tribble(
 ~"var", ~"name",
 "pv", "Photovoltaic PGT",
 "windOnshore", "Onshore wind PGT",
 "windOffshore", "Offshore wind PGT",
 "netherlandsElectricitySpotMarket", "DutchMarket",
 "germanyElectricitySpotMarket", "GermanMarket"         
)

name_to_var_trans <- name_to_var$var
names(name_to_var_trans) <- name_to_var$name

save(final_function_parameters, file = "../resources/sources/return_mapping/final_function_parameters.Rdata")

for(line in 1:nrow(final_function_parameters)){
  
  modelledRoeMin = final_function_parameters[[line,"modelled_roe_min"]]
  modelledRoeMax = final_function_parameters[[line,"modelled_roe_max"]]
  intercept = final_function_parameters[[line,"intercept"]]
  slope = final_function_parameters[[line,"slope"]]
  market = name_to_var_trans[[final_function_parameters[[line,"market"]]]]
  technology = name_to_var_trans[[final_function_parameters[[line,"technology"]]]]

  my_output <- glue(        
    "EmpiricalMappingFunctionParameter empiricalMappingFunction{line} = new EmpiricalMappingFunctionParameter();
        empiricalMappingFunction{line}.setModelledRoeMin({modelledRoeMin});
        empiricalMappingFunction{line}.setModelledRoeMax({modelledRoeMax});
        empiricalMappingFunction{line}.setIntercept({intercept});
        empiricalMappingFunction{line}.setSlope({slope});
        empiricalMappingFunction{line}.setMarket({market});
        empiricalMappingFunction{line}.setTechnology({technology}); 
        reps.empiricalMappingFunctionParameters.add(empiricalMappingFunction{line});\n"
    )
  
  write_lines(
    x = my_output, 
    path = "../resources/sources/return_mapping/mappingfunction_javacode.txt", 
    append = TRUE)

}



```

